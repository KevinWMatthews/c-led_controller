Create tests for Pinmaps?
Add tests into libATtiny for unwired gpio?

CMake todo:
    Can we put libhw products in its CMakeLists.txt? Do we want the main app to have to know everything? It should just have an option, perhaps.

    Revisit CMAKE_PREFIX_PATH and CPPUTEST_HOME

    I am not sure if we would rather compile all LedController tests
    into a single executable or if we would rather have separate
    executables for each module.

Should we write an abstract layer for Timers? I don't need to yet, so don't.

_set() still lingers in production code. Leave this? Abstract it away?
If we switch processors/toolchains we will need to.

A "button press" triggers multiple interrupts because the pin state change is not clean.
Perhaps it's better to monitor the button state using a timer? I've seen a few recommendations in that regard. Do more research.

For testing interrupts, try rigging up a second ATtiny that periodically switches an output pin. If we wire this directly to the first ATtiny's INT0 pin, we should get a clean signal.

Rewrite notes/how-to/readme.
I want to be able to start this from scratch and get somewhere.

Implement an interrupt module.
    This will allow us to read a button press without the need for polling.

Implement a timer module.
    This will allow us to blink the LED.

Read documentation about the reset line.
Re-read documentation about initializing variables to 0.
    See man/man3/FAQ.3
        You shouldn't do it for global and static variables? It could waste space.

! Re-read documentation on passing IO ports as parameters to functions.
    I think I'm doing this correctly.
    Should I declare and define the mock registers as volatile? Probably?
Nice! All avr/io*.h header files include <sfr_defs.h> - Special Function Register definitions.
This file fills in the various PORTx, PINx, etc, defines that make special registers look like C variables:
    #define _SFR_IO8(io_addr) _MMIO_BYTE((io_addr) + __SFR_OFFSET)
Don't worry about __SFR_OFFSET.
Then:
    #include <inttypes.h>
    #define _MMIO_BYTE(mem_addr) (*(volatile uint8_t *)(mem_addr))

    In the end, special registers are simply defined as the value of a volatile uint*_t pointer.

See if we can use macros for setting and clearing bits. This could save code space for me?

Does AVR provide SBI() and CBI() macros? I thought so....
    These macros are deprecated. See avr/include/compat/deprecated.h .
    Instead, these can be re-implemented using the _BV() (byte value) macro.
    Perhaps this macro solves my GET_BIT issues?

    From http://www.microchip.com/webdoc/AVRLibcReferenceManual/group__avr__sfr.html:
        "Porting programs that use the deprecated sbi/cbi macros
            Access to the AVR single bit set and clear instructions are provided via the standard C bit manipulation commands.
            The sbi and cbi macros are no longer directly supported.
                sbi (sfr,bit) can be replaced by sfr |= _BV(bit) .
                    i.e.: sbi(PORTB, PB1); is now PORTB |= _BV(PB1);
                cbi (sfr,bit) is now sfr &= ~(_BV(bit));
        This actually is more flexible than having sbi directly, as the optimizer will use a hardware sbi if appropriate,
        or a read/or/write operation if not appropriate.
        You do not need to keep track of which registers sbi/cbi will operate on."

    Perhaps with these we'd only need BitManip.h on my PC, unless there is some C standard library file that provides such operations.

Test all of my macros after I do this.
    Where does BitManip.h belong? I'd like to be able to use these in tests, too.
    They probably belong in the toolchain avr mock.
    See where AVR defines them.

See what else we can use from <avr/sfr_defs.h>:
    bit_is_set
    bit_is_clear
    loop_until_bit_is_set
    loop_until_bit_is_clear

Learn more about atomic operations: <util/atomic.h>

Remove old LedHw interface. It is no longer needed.
Remove dead tests and files:
    Led2.h -> Led_ATtiny861.c -> ATtiny861.h
Convert other modules to use a similar path.

Try to support tests during cross-compilation.
    Will run into the bug that the chip is too small!
    Re-read the FAQ and man pages to learn about compiling C++ code for the AVR.

Learn about how strings are stored in memory.

Do you need to specify the toolchain file first on the command line?

Consider setting CPPUTEST_HOME as an environment variable rather than a preprocessor (-D) option.

Holy crap! Check out the 'make help' target for CppUTest. I have much to learn.

Create a second executable/new product that toggles multiple LEDs.

Add Config.h file per project?

Where should led/gpio mapping be defined? In Led.h or LedMapping.h?
Similarly for GPIO.
Led.h should have no hardware references.

Move compiler flags out of toolchain file?

Perhaps I should pull out the specific wiring details into a separate header file.
Can we use macros?

Add an LED toggle function. Doesn't the hardware specifically support this?

Replace set_gpio_state() with a function pointer.
This will allow us to set the PORT register on a production build and the PORT and PIN registers on a local/test build.

Can we remove ATTN861_GPIO_MAX?

I think stddef.h in the mock hw is defining NULL... or something?


Remove initial state from ButtonObserver. It is unneeded in the foreseeable future.

Are buttons high by default? Design the hardware to ensure that this is the case.

Later on we'll need to verify that a single GPIO is not used twice!!

Flash something to the ATtiny!
Create a Makefile target that will do this.

How to run tests all at once?

Expand tests is HW library - test all GPIO.

How/if/when to check for calloc fail?

Why doesn't the Makefile throw an error if I forget to return a value?
    This is when a C++ function is calling C code.

Look into RESET pin and Brown Out Detection.

Run cross-compiled unit tests in QEMU (can we run them on the chip itself?).

See if I can use include-what-you-use:
    <lang>_INCLUDE_WHAT_YOU_USE
        Runs the respective tool along the with compiler.
        Diagnostics are visible in your IDE.
        Diagnostics are visible on CDash.
    LINK_WHAT_YOU_USE
        links with -Wl,--no-as-needed, then runs ldd -r -u
    <lang> is either C or CXX.
    Each of those properties is initialzied with CMAKE_<property

Fix status macros in gpio library. They are generic.

Standardize module names....

Rename Mock_ATtiny.h to something specific to GPIO.

Read this:
    https://stackoverflow.com/questions/43123571/generate-list-files-with-cmake

The CppUTest documentation states that we need to add:
    CXXFLAGS += -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorNewMacros.h
    CFLAGS += -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorMallocMacros.h
However, I'm only adding MallocMacros and it works...
