Make something actually run on the hardware!
    What should the LedHw layer actually do?
    I wonder if we can take it out and have the Led initialize directly from the chip.
    This could work but then we're stuck with that specific cpu.
    How about this:
        All chips use the general LedHw interface.
        Each schematic/product can/will implement its own interface. So,
        rather than having LedHw_ATtiny861.c, we'll have
            LedHw_led_with_button_ATtiny861.c
            LedHw_<another_product>_ATtiny861.c
        This will allow us to account for differing schematics.
        Perhaps I should pull out the specific wiring details into a separate header file.
        Don't want to be searching through source code! Unfortunately, I don't know how to do that.


Look into RESET pin and Brown Out Detection.

AVR compilation:
    If we can't get unit tests working for the AVR, remove/move the requirement for CppUTest.
    Compile CppUTest for AVR? How will we work around chip size?


Test LedController module

Remove initial state from ButtonObserver. It is unneeded in the foreseeable future.

Create button interface.
Toggle LED state with button press.
    -> I think we need to create a ButtonHW interface.

Are buttons high by default? Design the hardware to ensure that this is the case.

Should Test_Led verify that calls were made to the abstraction layer? Or to the HW?
I'll bet that is should check on some mock HW. Don't we want to verify that the LED state actually changes?

Later on we'll need to verify that a single GPIO is not used twice!!

Rename HW library from ATtiny861 to HwATtiny861

Learn the difference between add_custom_target and add_custom_command.

Flash something to the ATtiny!
Create a Makefile target that will do this.

How to run tests all at once? Hijack CMake's 'make test' target? Create a tew target?

Finish setting up cross-compilation:
    https://github.com/davisford/cmake-cpputest
    https://cmake.org/cmake/help/v3.3/manual/cmake-toolchains.7.html
    https://cmake.org/Wiki/CMake_Cross_Compiling
    https://github.com/danielotero/Generic-avr.cmake/blob/master/Generic-avr.cmake
    https://github.com/mkleemann/cmake-avr/blob/master/generic-gcc-avr.cmake
    http://nnarain.github.io/2016/03/29/AVR-CMake-Toolchain.html

CMake is configured to override anything that the user specifies for CMAKE_INSTALL_PREFIX.
Rewrite CMakeLists to provide a default but give user flexibility?

Cross-compile production code.

Cross-compile test code.
Run cross-compiled unit tests in QEMU (can we run them on the chip itself?).

Rethink how hw source code and mock source code is arranged. It's rather like it's own project, or at least I think it should be.

Does C throw an -fpermissive warning?

Test SetState() for all other ATtiny861 GPIOs.

Can't get autotools to compile CppUTest for the sitara; the libraries' .o files are still x86_64.
Cmake works.

Expand tests is HW library - test all GPIO.

Double-check tests in LedHw layer. Did we get everything?

Add CppUTestExt to all test executables. This enables malloc Memory checking!!

How to check for calloc fail?

Why doesn't the Makefile throw an error if I forget to return a value?
    This is when a C++ function is calling C code.
